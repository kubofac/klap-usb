<!DOCTYPE html>
<html lang="ja">
<head>
Â  Â  <meta charset="UTF-8" />
Â  Â  <meta name="viewport" content="width=device-width, user-scalable=no">
Â  Â  <title>KLAP_ver3 (WebUSB 10Hzå¯¾å¿œ)</title>
Â  Â  <link rel="manifest" href="/manifest.json">
Â  Â  <style>
Â  Â  Â  Â  html, body {
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  font-family: Arial, sans-serif;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  min-height: 100vh;
Â  Â  Â  Â  Â  Â  background-color: #000000;
Â  Â  Â  Â  Â  Â  color: #ffffff;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  }

Â  Â  Â  Â  #container {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  background: #1c1c1e;
Â  Â  Â  Â  Â  Â  border-radius: 10px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  max-width: 100%;
Â  Â  Â  Â  Â  Â  margin: 20px auto;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #main-content {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  gap: 20px;
Â  Â  Â  Â  Â  Â  align-items: flex-start;
Â  Â  Â  Â  Â  Â  justify-content: space-between;
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #time-display-column {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: flex-start;
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  #lap-list-column {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  width: 400px;
Â  Â  Â  Â  Â  Â  flex-shrink: 0;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #display1 {
Â  Â  Â  Â  Â  Â  font-size: 90px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: #eeeeee;
Â  Â  Â  Â  Â  Â  margin-bottom: 5px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #display {
Â  Â  Â  Â  Â  Â  font-size: 60px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: #cccccc;
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #lap_list {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 200px;
Â  Â  Â  Â  Â  Â  overflow-y: auto;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  background-color: #1c1c1e;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #lap_list div {
Â  Â  Â  Â  Â  Â  font-size: 2.5em;
Â  Â  Â  Â  Â  Â  margin-bottom: 5px;
Â  Â  Â  Â  Â  Â  color: #dddddd;
Â  Â  Â  Â  }

Â  Â  Â  Â  #buttons-row {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: space-around;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  padding-top: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .button {
Â  Â  Â  Â  Â  Â  border: 1px solid #3a3a3c;
Â  Â  Â  Â  Â  Â  background-color: #2c2c2e;
Â  Â  Â  Â  Â  Â  padding: 10px 15px;
Â  Â  Â  Â  Â  Â  color: #ffffff;
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  Â  Â  font-weight: 500;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: background-color 0.2s ease;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .button:hover { background-color: #4a4a4e; }
Â  Â  Â  Â  #start:active { background-color: #4a804a; }
Â  Â  Â  Â  #reset:active { background-color: #993333; }
Â  Â  Â  Â  #lap:active { background-color: #4a4a4e; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .no-setting { background-color: #ff4d4d; }
Â  Â  Â  Â  .no-setting:hover { background-color: #ff6666; }
Â  Â  Â  Â  .no-setting:active { background-color: #e64444; }

Â  Â  Â  Â  .no-gps { background-color: #ff4d4d; }
Â  Â  Â  Â  .no-gps:hover { background-color: #ff6666; }
Â  Â  Â  Â  .no-gps:active { background-color: #e64444; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .active-blue { background-color: #007aff; }
Â  Â  Â  Â  .active-blue:hover { background-color: #3399ff; }
Â  Â  Â  Â  .active-blue:active { background-color: #0066cc; }

Â  Â  Â  Â  #debug-overlay {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  background-color: transparent;
Â  Â  Â  Â  Â  Â  color: #ffffff;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  z-index: 1000;
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  line-height: 1.5;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  opacity: 0.9;
Â  Â  Â  Â  Â  Â  text-align: left;
Â  Â  Â  Â  }
Â  Â  Â  Â  .status-text {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  }
Â  Â  Â  Â  #debug-overlay #debugInfo {
Â  Â  Â  Â  Â  Â  margin-top: 5px;
Â  Â  Â  Â  Â  Â  line-height: 1.2;
Â  Â  Â  Â  }
Â  Â  Â  Â  /* NMEAãƒ­ã‚°è¡¨ç¤ºã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
Â  Â  Â  Â  #nmeaLog {
Â  Â  Â  Â  Â  Â  height: 30px; /* 1è¡ŒãŒè¦‹ãˆã‚‹ç¨‹åº¦ã®é«˜ã•ã«åˆ¶é™ */
Â  Â  Â  Â  Â  Â  overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– */
Â  Â  Â  Â  Â  Â  border: 1px solid #ccc;Â 
Â  Â  Â  Â  Â  Â  padding: 5px;Â 
Â  Â  Â  Â  Â  Â  font-size: 10px;
Â  Â  Â  Â  Â  Â  background-color: #000;
Â  Â  Â  Â  Â  Â  white-space: pre; /* æŠ˜ã‚Šè¿”ã—ã‚’ç„¡åŠ¹åŒ–ã—ã¦1è¡Œè¡¨ç¤ºã‚’å¼·èª¿ */
Â  Â  Â  Â  Â  Â  pointer-events: all;Â 
Â  Â  Â  Â  Â  Â  line-height: 1;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  @media (max-width: 480px) {
Â  Â  Â  Â  Â  Â  #main-content {
Â  Â  Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  Â  Â  gap: 20px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #time-display-column, #lap-list-column {
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #buttons-row {
Â  Â  Â  Â  Â  Â  Â  Â  flex-direction: row;
Â  Â  Â  Â  Â  Â  Â  Â  flex-wrap: wrap;
Â  Â  Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  .button {
Â  Â  Â  Â  Â  Â  Â  Â  width: auto;
Â  Â  Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  Â  Â  padding: 10px 8px;
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #display1 { font-size: 40px; }
Â  Â  Â  Â  Â  Â  #display { font-size: 25px; }
Â  Â  Â  Â  Â  Â  #lap_list div {
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 1.6em;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #debug-overlay {
Â  Â  Â  Â  Â  Â  Â  Â  width: auto;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #nmeaLog {
Â  Â  Â  Â  Â  Â  Â  Â  /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯å°‘ã—å¤§ããè¡¨ç¤º */
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 8px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </style>
</head>

<body>
<div id="container">
Â  Â  <div id="debug-overlay">
Â  Â  Â  Â  <p id="status-display" class="status-text">GPSè¨­å®š: æœªå–å¾—</p>
Â  Â  Â  Â  <div id="debugInfo" class="status-text"></div>
Â  Â  Â  Â  <p class="status-text">NMEA Raw Data (Latest):</p>
Â  Â  Â  Â  <pre id="nmeaLog">No NMEA data yet...</pre>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="main-content">
Â  Â  Â  Â  <div id="time-display-column">
Â  Â  Â  Â  Â  Â  <div id='display1'>00:00.000</div>
Â  Â  Â  Â  Â  Â  <div id='display'>00:00:00.000</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="lap-list-column">
Â  Â  Â  Â  Â  Â  <div id='lap_list'></div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div id="buttons-row">
Â  Â  Â  Â  <button id="start" class="button">start</button>
Â  Â  Â  Â  <button id="lap" class="button">lap</button>
Â  Â  Â  Â  <button id="reset" class="button">reset</button>
Â  Â  Â  Â  <button id="gpsButton" class="button no-gps">GPS</button>
Â  Â  Â  Â  <button id="getSettingsBtn" class="button no-setting">GET</button>
Â  Â  </div>
</div>

<script>
'use strict';
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
const SW_STATE = { STOP: 0, RUN: 1, PAUSE: 2 };
let swState = SW_STATE.STOP;
let startTime = 0;
let lapRecords = [];
let lapCount = 0;
let countUpTimerId = null;
let lapTimerId = null;
let lapStartTime = 0;
let isGpsRunning = false;
let lastPosition = null;
let previousSideOfLine = null;
let lastLapTime = 0;
let gpsThresholdValue = 20;
let lapCoolDown = 15000;
let isSettingsLoaded = false;
let lapFixedDisplayTimeoutId = null;

const elem = {
Â  Â  display: null,
Â  Â  display1: null,
Â  Â  lap_list: null,
Â  Â  statusDisplay: null,
Â  Â  debugInfo: null,
Â  Â  startButton: null,
Â  Â  resetButton: null,
Â  Â  lapButton: null,
Â  Â  gpsButton: null,
Â  Â  getSettingsBtn: null,
Â  Â  nmeaLog: nullÂ 
};

// GPSãƒ©ãƒƒãƒ—è¨ˆæ¸¬ç”¨å¤‰æ•° - localStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
let LAP_LINE_P1 = { lat: 0, lon: 0 };
let LAP_LINE_P2 = { lat: 0, lon: 0 };

// --- WebUSBé–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let device = null;
let keepReading = true;
let nmeaBuffer = '';
const NMEA_VENDOR_ID = 0x1546;Â  Â Â 
const NMEA_PRODUCT_ID = 0x01A8;Â Â 
// ğŸ’¡ NMEAãŒè¡¨ç¤ºã•ã‚Œã€æ¥ç¶šãŒç¢ºå®šã—ãŸè¨­å®šå€¤
const IN_ENDPOINT = 2;Â  Â  Â  Â  Â  Â Â 
const INTERFACE_NUMBER = 1;

// --- æ›´æ–°ãƒ¬ãƒ¼ãƒˆ/ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºç”¨å¤‰æ•° ---
let lastUpdateTime = 0;Â 
let updateCounter = 0;Â 
let displayRateTimer = null;Â 
let currentUpdateRate = 0;Â 
let currentLat = 0.0;
let currentLon = 0.0;

// ğŸ’¡ ç”»é¢ãƒ‡ãƒãƒƒã‚°ç”¨ã«è¿½åŠ ã—ãŸå¤‰æ•°
let latestRmcStatus = 'N/A';
let latestRmcRawLatLon = 'N/A';
// ------------------------------------
// ğŸ’¡ è¿½åŠ : RMCæ›´æ–°ãƒ¬ãƒ¼ãƒˆè¨ˆæ¸¬ç”¨å¤‰æ•°
let rmcUpdateCounter = 0;
let currentRmcUpdateRate = 0;
// ------------------------------------

// --- ã‚¹ãƒˆãƒƒãƒ—ã‚¦ã‚©ãƒƒãƒé–¢é€£ã®é–¢æ•°ï¼ˆçœç•¥ï¼‰ ---

const totalTimePrint = (time) => {
Â  Â  let h = Math.floor(time / 3600000);
Â  Â  let m = Math.floor((time % 3600000) / 60000);
Â  Â  let s = Math.floor((time % 60000) / 1000);
Â  Â  let ms = Math.floor(time % 1000);
Â  Â Â 
Â  Â  h = ('0' + h).slice(-2);
Â  Â  m = ('0' + m).slice(-2);
Â  Â  s = ('0' + s).slice(-2);
Â  Â  ms = ('00' + ms).slice(-3);
Â  Â Â 
Â  Â  if (elem.display) elem.display.textContent = `${h}:${m}:${s}.${ms}`;
};

const lapTimeToString = (time) => {
Â  Â  let m = Math.floor(time / 60000);
Â  Â  let s = Math.floor(time % 60000 / 1000);
Â  Â  let ms = Math.floor(time % 1000);
Â  Â Â 
Â  Â  m = ('0' + m).slice(-2);
Â  Â  s = ('0' + s).slice(-2);
Â  Â  ms = ('00' + ms).slice(-3);
Â  Â Â 
Â  Â  return `${m}:${s}.${ms}`;
};

const countUp = () => {
Â  Â  countUpTimerId = requestAnimationFrame(() => {
Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  const elapsedTime = now - startTime;
Â  Â  Â  Â  totalTimePrint(elapsedTime);
Â  Â  Â  Â  countUp();
Â  Â  });
};

const startRealtimeLap = () => {
Â  Â  if (swState === SW_STATE.RUN) {
Â  Â  Â  Â  lapTimerId = requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  const lapElapsedTime = now - lapStartTime;
Â  Â  Â  Â  Â  Â  const lapDisplay = lapTimeToString(lapElapsedTime);
Â  Â  Â  Â  Â  Â  if (elem.display1) elem.display1.textContent = lapDisplay;
Â  Â  Â  Â  Â  Â  startRealtimeLap();
Â  Â  Â  Â  });
Â  Â  }
};

const lapTimePrint = (time) => {Â  Â Â 
Â  Â  const lapDuration = lapTimeToString(time);
Â  Â  const lapDiv = document.createElement('div');
Â  Â  lapDiv.textContent = `[${lapCount}] ${lapDuration}`;Â  Â Â 
Â  Â  lapDiv.style.fontSize = '2.5em';
Â  Â  if (elem.lap_list) {
Â  Â  Â  Â  elem.lap_list.insertBefore(lapDiv, elem.lap_list.firstChild);
Â  Â  }
Â  Â  lapRecords.push({ count: lapCount, time: lapDuration });Â  Â Â 
};

const updateButtonDisplay = () => {
Â  Â  if (elem.lapButton) {
Â  Â  Â  Â  elem.lapButton.style.display = (swState === SW_STATE.RUN) ? 'inline-block' : 'none';
Â  Â  }
Â  Â  if (elem.resetButton) {
Â  Â  Â  Â  elem.resetButton.style.display = (swState === SW_STATE.STOP || swState === SW_STATE.PAUSE) ? 'inline-block' : 'none';
Â  Â  }
Â  Â  if (elem.startButton) {
Â  Â  Â  Â  elem.startButton.textContent = (swState === SW_STATE.RUN) ? 'stop' : 'start';
Â  Â  }
};

const clickStartSW = () => {
Â  Â  if (!isSettingsLoaded && swState === SW_STATE.STOP) {
Â  Â  Â  Â  if (elem.debugInfo) {
Â  Â  Â  Â  Â  Â  elem.debugInfo.innerHTML = `GPSè¨­å®šãŒæœªå–å¾—ã§ã™ã€‚æ‰‹å‹•ã§ã®è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™ã€‚<br>${elem.debugInfo.innerHTML}`;
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  if (swState === SW_STATE.STOP) {
Â  Â  Â  Â  swState = SW_STATE.RUN;
Â  Â  Â  Â  startTime = Date.now();
Â  Â  Â  Â  lapStartTime = Date.now();
Â  Â  Â  Â  lapCount = 0;
Â  Â  Â  Â  elem.lap_list.innerHTML = '';
Â  Â  Â  Â  countUp();
Â  Â  Â  Â  startRealtimeLap();
Â  Â  } else if (swState === SW_STATE.RUN) {
Â  Â  Â  Â  swState = SW_STATE.PAUSE;
Â  Â  Â  Â  cancelAnimationFrame(countUpTimerId);
Â  Â  Â  Â  cancelAnimationFrame(lapTimerId);
Â  Â  Â  Â  if (lapFixedDisplayTimeoutId) {
Â  Â  Â  Â  Â  Â  clearTimeout(lapFixedDisplayTimeoutId);
Â  Â  Â  Â  }
Â  Â  } else if (swState === SW_STATE.PAUSE) {
Â  Â  Â  Â  swState = SW_STATE.RUN;
Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  const pausedTime = now - lapStartTime;
Â  Â  Â  Â  startTime += pausedTime;
Â  Â  Â  Â  lapStartTime = now;
Â  Â  Â  Â  countUp();
Â  Â  Â  Â  startRealtimeLap();
Â  Â  }
Â  Â  updateButtonDisplay();
};

const clickLapSW = () => {
Â  Â  if (swState === SW_STATE.RUN) {
Â  Â  Â  Â  lapCount++;
Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  const lapDuration = now - lapStartTime;
Â  Â  Â  Â  lapTimePrint(lapDuration);Â  Â Â 
Â  Â  Â  Â  lapStartTime = now;
Â  Â  Â  Â  cancelAnimationFrame(lapTimerId);
Â  Â  Â  Â  startRealtimeLap();
Â  Â  }
};

const clickResetSW = () => {
Â  Â  swState = SW_STATE.STOP;
Â  Â  startTime = 0;
Â  Â  lapRecords = [];
Â  Â  lapCount = 0;
Â  Â  cancelAnimationFrame(countUpTimerId);
Â  Â  cancelAnimationFrame(lapTimerId);
Â  Â  if (lapFixedDisplayTimeoutId) {
Â  Â  Â  Â  clearTimeout(lapFixedDisplayTimeoutId);
Â  Â  }
Â  Â  totalTimePrint(0);
Â  Â  if (elem.lap_list) elem.lap_list.innerHTML = '';
Â  Â  if (elem.display1) elem.display1.textContent = '00:00.000';
Â  Â  updateButtonDisplay();
Â  Â  stopGps();
};

const clickGpsButton = () => {
Â  Â  if (!isGpsRunning) {
Â  Â  Â  Â  startGps();
Â  Â  } else {
Â  Â  Â  Â  stopGps();
Â  Â  }
};

const getSettings = () => {
Â  Â  const p1Lat = localStorage.getItem('startLineP1Lat');
Â  Â  const p1Lon = localStorage.getItem('startLineP1Lon');
Â  Â  const p2Lat = localStorage.getItem('startLineP2Lat');
Â  Â  const p2Lon = localStorage.getItem('startLineP2Lon');
Â  Â  const threshold = localStorage.getItem('gpsThreshold');
Â  Â  const coolDown = localStorage.getItem('lapCoolDownTime');Â  Â Â 

Â  Â  if (p1Lat && p1Lon && p2Lat && p2Lon) {
Â  Â  Â  Â  LAP_LINE_P1 = { lat: parseFloat(p1Lat), lon: parseFloat(p1Lon) };
Â  Â  Â  Â  LAP_LINE_P2 = { lat: parseFloat(p2Lat), lon: parseFloat(p2Lon) };
Â  Â  Â  Â  gpsThresholdValue = threshold ? parseFloat(threshold) : 20;
Â  Â  Â  Â  lapCoolDown = coolDown ? parseFloat(coolDown) : 15000;Â  Â Â 

Â  Â  Â  Â  elem.statusDisplay.textContent = `GPSè¨­å®š: OK (é–¾å€¤: ${gpsThresholdValue}m / C/D: ${lapCoolDown / 1000}ç§’)`;
Â  Â  Â  Â  elem.debugInfo.innerHTML = "GPSè¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚";
Â  Â  Â  Â  isSettingsLoaded = true;
Â  Â  Â  Â  elem.getSettingsBtn.classList.remove('no-setting');
Â  Â  Â  Â  elem.getSettingsBtn.classList.add('active-blue');
Â  Â  } else {
Â  Â  Â  Â  elem.statusDisplay.textContent = 'GPSè¨­å®š: æœªè¨­å®šï¼ˆè¨­å®šãƒ„ãƒ¼ãƒ«ã§ä¿å­˜ã—ã¦ãã ã•ã„ï¼‰';
Â  Â  Â  Â  elem.debugInfo.innerHTML = "localStorageã«GPSè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
Â  Â  Â  Â  isSettingsLoaded = false;
Â  Â  Â  Â  elem.getSettingsBtn.classList.remove('active-blue');
Â  Â  Â  Â  elem.getSettingsBtn.classList.add('no-setting');
Â  Â  }
};


// ----------------------------------------------------------------------
// WebUSB/NMEA/æ›´æ–°ãƒ¬ãƒ¼ãƒˆé–¢é€£ã®é–¢æ•° (dmsToDecimalä¿®æ­£)
// ----------------------------------------------------------------------

// NMEAã®DMMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆåº¦åˆ†.åˆ†ï¼‰ã‚’10é€²æ•°ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function dmsToDecimal(dmm, direction) {
Â  Â  if (!dmm) return NaN;
Â  Â Â 
Â  Â  const dotIndex = dmm.indexOf('.');
Â  Â Â 
Â  Â  if (dotIndex !== -1) {
Â  Â  Â  Â  // ğŸ’¡ ä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯: NMEA DMMå½¢å¼ã§ã¯ã€ã€Œåˆ†ã€ã¯å¸¸ã«å°æ•°ç‚¹å‰ã®2æ¡ã¨å›ºå®š
Â  Â  Â  Â  const minuteStartIndex = dotIndex - 2;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (minuteStartIndex > 0) {
Â  Â  Â  Â  Â  Â  const degrees = parseInt(dmm.substring(0, minuteStartIndex));
Â  Â  Â  Â  Â  Â  const minutes = parseFloat(dmm.substring(minuteStartIndex));
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isNaN(degrees) || isNaN(minutes)) return NaN;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let decimal = degrees + (minutes / 60);

Â  Â  Â  Â  Â  Â  if (direction === 'S' || direction === 'W') {
Â  Â  Â  Â  Â  Â  Â  Â  decimal = -decimal;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return decimal;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // åº¦æ•°ãŒå­˜åœ¨ã—ãªã„ãªã©ã®ç•°å¸¸ãƒ‡ãƒ¼ã‚¿
Â  Â  Â  Â  Â  Â  return NaN;
Â  Â  Â  Â  }

Â  Â  } else {
Â  Â  Â  Â  // å°æ•°ç‚¹ãŒãªã„å ´åˆï¼ˆå¤ã„ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¾ãŸã¯è§£æå¤±æ•—ãƒ‡ãƒ¼ã‚¿ï¼‰ã®å¯¾å¿œ
Â  Â  Â  Â  const num = parseFloat(dmm);
Â  Â  Â  Â  if (isNaN(num)) return NaN;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (dmm.length >= 4) {
Â  Â  Â  Â  Â  Â  const minuteRaw = dmm.slice(-2);
Â  Â  Â  Â  Â  Â  const degreeRaw = dmm.slice(0, -2);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const degrees = parseInt(degreeRaw);
Â  Â  Â  Â  Â  Â  const minutes = parseInt(minuteRaw);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let decimal = degrees + (minutes / 60);

Â  Â  Â  Â  Â  Â  if (direction === 'S' || direction === 'W') {
Â  Â  Â  Â  Â  Â  Â  Â  decimal = -decimal;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return decimal;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  return NaN;
Â  Â  Â  Â  }
Â  Â  }
}

// NMEAãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è§£æã—ã€ä½ç½®æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ (ç°¡ç•¥åŒ–ã•ã‚ŒãŸãƒ‘ãƒ¼ã‚µãƒ¼)
function parseNmeaLine(line) {
Â  Â  const parts = line.split(',');
Â  Â Â 
Â  Â  // ----------------------------------------------------
    // ğŸ’¡ ä¿®æ­£ç®‡æ‰€: NMEAãƒ˜ãƒƒãƒ€ãƒ¼ã®æœ«å°¾ãŒRMCã§ã‚ã‚Œã°ã€ã©ã®GNSSãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã§ã‚‚å—ã‘å…¥ã‚Œã‚‹
    // ----------------------------------------------------
Â  Â  if (parts[0].toUpperCase().endsWith('RMC') && parts.length >= 10 && parts[2] === 'A') {
Â  Â  Â  Â  const lat = dmsToDecimal(parts[3], parts[4]);
Â  Â  Â  Â  const lon = dmsToDecimal(parts[5], parts[6]);Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  const speedKnot = parseFloat(parts[7]) || 0;
Â  Â  Â  Â  const speedMps = speedKnot * 0.514444; // ãƒãƒƒãƒˆã‚’ãƒ¡ãƒ¼ãƒˆãƒ«/ç§’ã«å¤‰æ›

Â  Â  Â  Â  if (isNaN(lat) || isNaN(lon)) return null;

Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  coords: {
Â  Â  Â  Â  Â  Â  Â  Â  latitude: lat,
Â  Â  Â  Â  Â  Â  Â  Â  longitude: lon,
Â  Â  Â  Â  Â  Â  Â  Â  speed: speedMps, // m/s
Â  Â  Â  Â  Â  Â  Â  Â  accuracy: 1
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  timestamp: Date.now()Â 
Â  Â  Â  Â  };
Â  Â  }
Â  Â  return null;
}

// NMEAãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒãƒƒãƒ•ã‚¡ã‚’ç®¡ç†ã—ã€è¡Œã”ã¨ã«ãƒ‘ãƒ¼ã‚µãƒ¼ã«æ¸¡ã™
function processNmeaData(data) {
Â  Â  nmeaBuffer += data;
Â  Â  let newlineIndex;

Â  Â  while ((newlineIndex = nmeaBuffer.indexOf('\n')) !== -1) {
Â  Â  Â  Â  const line = nmeaBuffer.substring(0, newlineIndex).trim();
Â  Â  Â  Â  nmeaBuffer = nmeaBuffer.substring(newlineIndex + 1);

Â  Â  Â  Â  if (line.startsWith('$') && line.length > 5) {
Â  Â  Â  Â  Â  Â  const position = parseNmeaLine(line);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // ğŸ’¡ RMCã‚»ãƒ³ãƒ†ãƒ³ã‚¹ã‹ã‚‰ç·¯åº¦çµŒåº¦ã‚’æŠ½å‡ºã—ã€ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºç”¨ã®å¤‰æ•°ã‚’æ›´æ–°
Â  Â  Â  Â  Â  Â  if (line.toUpperCase().includes('RMC')) { // ä¿®æ­£å¾Œã®ãƒ­ã‚¸ãƒƒã‚¯ã«åˆã‚ã›ã¦includes('RMC')ã‚’ä½¿ç”¨
Â  Â  Â  Â  Â  Â  Â  Â  Â try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const parts = line.split(',');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // 1. å°æ•°ç‚¹ä»¥ä¸‹6æ¡ã®ãƒ‡ã‚·ãƒãƒ«ç·¯åº¦ãƒ»çµŒåº¦ã‚’æ›´æ–° (ç”»é¢ä¸Šéƒ¨è¡¨ç¤ºç”¨)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentLat = dmsToDecimal(parts[3], parts[4]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentLon = dmsToDecimal(parts[5], parts[6]);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // 2. RMCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ã€ç”Ÿã®ç·¯åº¦çµŒåº¦ãƒ‡ãƒ¼ã‚¿ï¼ˆç”»é¢ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰ã‚’æ›´æ–°
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â latestRmcStatus = parts.length > 2 ? parts[2] : 'N/A';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // ç·¯åº¦çµŒåº¦ã®ç”Ÿãƒ‡ãƒ¼ã‚¿ã¨ã€ãã‚Œãã‚Œã®N/S/E/Wã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’é€£çµ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const rawLat = parts.length > 3 ? `${parts[3]} ${parts[4]}` : 'N/A';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const rawLon = parts.length > 5 ? `${parts[5]} ${parts[6]}` : 'N/A';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â latestRmcRawLatLon = `${rawLat} / ${rawLon}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // ----------------------------------------------------
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // ğŸ’¡ è¿½åŠ : RMCæ›´æ–°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â rmcUpdateCounter++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // ----------------------------------------------------
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error("RMC line parse error:", e, "Line:", line);
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // onWebUsbPositionUpdateã®å‘¼ã³å‡ºã—ã¯ position ãŒæœ‰åŠ¹ãªå ´åˆ ('A' ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹) ã®ã¿
Â  Â  Â  Â  Â  Â  if (position && swState === SW_STATE.RUN) {
Â  Â  Â  Â  Â  Â  Â  Â  onWebUsbPositionUpdate(position);Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
}

// 1ç§’ã”ã¨ã«æ›´æ–°ãƒ¬ãƒ¼ãƒˆã‚’è¨ˆç®—ã—ã¦è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹
function startRateMeasurement() {
Â  Â  if (displayRateTimer !== null) {
Â  Â  Â  Â  clearInterval(displayRateTimer);
Â  Â  Â  Â  displayRateTimer = null;
Â  Â  }
Â  Â Â 
Â  Â  currentUpdateRate = 0;
Â  Â  updateCounter = 0;Â 
Â  Â  // ğŸ’¡ RMCãƒ¬ãƒ¼ãƒˆè¨ˆæ¸¬ç”¨ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆ
Â  Â  currentRmcUpdateRate = 0;
Â  Â  rmcUpdateCounter = 0;
Â  Â Â 
Â  Â  displayRateTimer = setInterval(() => {
Â  Â  Â  Â  currentUpdateRate = updateCounter;Â 
Â  Â  Â  Â  updateCounter = 0;Â 
Â  Â  Â  Â  // ğŸ’¡ RMCãƒ¬ãƒ¼ãƒˆè¨ˆæ¸¬ã®è¨ˆç®—
Â  Â  Â  Â  currentRmcUpdateRate = rmcUpdateCounter;
Â  Â  Â  Â  rmcUpdateCounter = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  updateDebugDisplay();Â 
Â  Â  }, 1000);Â 
}

// æ›´æ–°ãƒ¬ãƒ¼ãƒˆã®è¨ˆæ¸¬ã‚’åœæ­¢
function stopRateMeasurement() {
Â  Â  if (displayRateTimer !== null) {
Â  Â  Â  Â  clearInterval(displayRateTimer);
Â  Â  Â  Â  displayRateTimer = null;Â 
Â  Â  }
Â  Â  currentUpdateRate = 0;
Â  Â  currentRmcUpdateRate = 0; // ğŸ’¡ RMCãƒ¬ãƒ¼ãƒˆã‚‚ãƒªã‚»ãƒƒãƒˆ
}

// ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateDebugDisplay() {
Â  Â  if (!elem.debugInfo) return;

Â  Â  // ğŸ’¡ è¡¨ç¤ºã‚’ä¿®æ­£: NMEAç·ãƒ¬ãƒ¼ãƒˆã¨RMCãƒ¬ãƒ¼ãƒˆã‚’åˆ†ã‘ã¦è¡¨ç¤º
Â  Â  const rateText = `ç·ãƒ¬ãƒ¼ãƒˆ: ${currentUpdateRate.toFixed(0)} Hz | RMCãƒ¬ãƒ¼ãƒˆ: ${currentRmcUpdateRate.toFixed(0)} Hz`;
Â  Â Â 
Â  Â  // ğŸ’¡ å°æ•°ç‚¹6æ¡ã®ãƒ‡ã‚·ãƒãƒ«è¡¨ç¤º
Â  Â  const latLonText = `DEC: ${currentLat.toFixed(6)} / ${currentLon.toFixed(6)}`;

Â  Â  // ğŸ’¡ RMCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ç”Ÿã®ç·¯åº¦çµŒåº¦ã‚’è¡¨ç¤º
Â  Â  const rmcStatusText = `RMC Status: ${latestRmcStatus}`;
Â  Â  const rmcRawText = `RAW DMM: ${latestRmcRawLatLon}`;
Â  Â Â 
Â  Â  const speedText = `é€Ÿåº¦: ${(lastPosition && lastPosition.speed !== null) ? lastPosition.speed.toFixed(2) : 'N/A'} m/s`;
Â  Â  const lapCountText = `å‘¨å›æ•°: ${lapCount}`;Â 

Â  Â  elem.debugInfo.innerHTML = `
Â  Â  Â  Â  ${rateText} | ${rmcStatusText}<br>
Â  Â  Â  Â  ${latLonText}<br>
Â  Â  Â  Â  ${rmcRawText}<br>
Â  Â  Â  Â  ${speedText} | ${lapCountText}
Â  Â  `;
Â  Â Â 
Â  Â  // RMCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ã¦è‰²ã‚’ä»˜ã‘ã‚‹ (A=ç·‘, V=èµ¤)
Â  Â  const statusColor = (latestRmcStatus === 'A') ? 'lime' : (latestRmcStatus === 'V' ? 'red' : 'white');
Â  Â  elem.debugInfo.style.color = statusColor;
}

// WebUSBãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Šãƒ«ãƒ¼ãƒ—
async function readLoop() {
Â  Â  const nmeaLogElement = elem.nmeaLog;Â 
Â  Â Â 
Â  Â  while (device && keepReading) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const result = await device.transferIn(IN_ENDPOINT, 512);Â 
Â  Â  Â  Â  Â  Â  if (result.status === 'ok' && result.data) {
Â  Â  Â  Â  Â  Â  Â  Â  const decoder = new TextDecoder('iso-8859-1');
Â  Â  Â  Â  Â  Â  Â  Â  const nmeaData = decoder.decode(result.data);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  updateCounter++;

Â  Â  Â  Â  Â  Â  Â  Â  if (nmeaLogElement && nmeaData.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lines = nmeaData.trim().split('\n');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lines.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const latestLine = lines[lines.length - 1].trim();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nmeaLogElement.textContent = latestLine;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  processNmeaData(nmeaData);Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  if (keepReading) {
Â  Â  Â  Â  Â  Â  Â  Â  elem.debugInfo.innerHTML = `USBèª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: ${error.message}`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  break;Â 
Â  Â  Â  Â  }
Â  Â  }
}

// WebUSBæ¥ç¶šã‚’é–‹å§‹
async function startWebUsbGps() {
Â  Â  try {
Â  Â  Â  Â  elem.statusDisplay.textContent = 'USBãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­...';
Â  Â  Â  Â  elem.gpsButton.textContent = 'æ¥ç¶šä¸­...';Â 

Â  Â  Â  Â  device = await navigator.usb.requestDevice({
Â  Â  Â  Â  Â  Â  filters: [{ vendorId: NMEA_VENDOR_ID, productId: NMEA_PRODUCT_ID }]
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  await device.open();
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (device.configuration === null) {
Â  Â  Â  Â  Â  Â  await device.selectConfiguration(device.configurations[0].configurationValue);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  await device.claimInterface(INTERFACE_NUMBER);
Â  Â  Â  Â Â 
Â  Â  Â  Â  elem.statusDisplay.textContent = 'GPSãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¥ç¶šå®Œäº†ã€‚ãƒ‡ãƒ¼ã‚¿ç›£è¦–ä¸­...';
Â  Â  Â  Â  elem.gpsButton.textContent = 'GPS (åœæ­¢)';
Â  Â  Â  Â  elem.gpsButton.classList.remove('no-gps');
Â  Â  Â  Â  elem.gpsButton.classList.add('active-blue');
Â  Â  Â  Â  isGpsRunning = true;
Â  Â  Â  Â  keepReading = true;
Â  Â  Â  Â Â 
Â  Â  Â  Â  startRateMeasurement();Â 
Â  Â  Â  Â  readLoop();Â 
Â  Â  Â  Â Â 
Â  Â  } catch (error) {
Â  Â  Â  Â  elem.debugInfo.innerHTML = `USBæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`;
Â  Â  Â  Â  stopGps();
Â  Â  }
}

// GPSç›£è¦–ã‚’é–‹å§‹ã™ã‚‹
function startGps() {
Â  Â  if (!isSettingsLoaded) {
Â  Â  Â  Â  elem.debugInfo.innerHTML = "GPSè¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚<br>GETãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨­å®šã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚";
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  startWebUsbGps();
}

// GPSç›£è¦–ã‚’åœæ­¢ã™ã‚‹
async function stopGps() {
Â  Â  stopRateMeasurement();Â 

Â  Â  keepReading = false;
Â  Â  if (device) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  await device.releaseInterface(INTERFACE_NUMBER);
Â  Â  Â  Â  Â  Â  await device.close();
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
Â  Â  Â  Â  }
Â  Â  Â  Â  device = null;
Â  Â  }
Â  Â  isGpsRunning = false;
Â  Â  elem.statusDisplay.textContent = 'GPSç›£è¦–åœæ­¢';
Â  Â  elem.gpsButton.textContent = 'GPS';
Â  Â  elem.gpsButton.classList.remove('active-blue');
Â  Â  elem.gpsButton.classList.add('no-gps');
Â  Â Â 
Â  Â  if(elem.nmeaLog) elem.nmeaLog.textContent = 'No NMEA data yet...';
Â  Â  currentLat = 0.0;
Â  Â  currentLon = 0.0;
Â  Â  latestRmcStatus = 'N/A';
Â  Â  latestRmcRawLatLon = 'N/A';
Â  Â  lastPosition = null;
Â  Â  updateDebugDisplay();
}

// WebUSBã‹ã‚‰ã®ä½ç½®æƒ…å ±æ›´æ–°å‡¦ç†ï¼ˆçœç•¥ï¼‰
function onWebUsbPositionUpdate(position) {
Â  Â  if (swState !== SW_STATE.RUN || !isGpsRunning) {
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  lastUpdateTime = Date.now();
Â  Â Â 
Â  Â  const currentLat = position.coords.latitude;
Â  Â  const currentLon = position.coords.longitude;
Â  Â  const currentTime = Date.now();
Â  Â Â 
Â  Â  // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ï¼ˆçœç•¥ï¼‰
Â  Â  const calculateDistance = (lat1, lon1, lat2, lon2) => {
Â  Â  Â  Â  const R = 6371e3;
Â  Â  Â  Â  const Ï†1 = lat1 * Math.PI / 180;
Â  Â  Â  Â  const Ï†2 = lat2 * Math.PI / 180;
Â  Â  Â  Â  const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
Â  Â  Â  Â  const Î”Î» = (lon2 - lon1) * Math.PI / 180;
Â  Â  Â  Â  const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
Â  Â  Â  Â  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
Â  Â  Â  Â  return R * c;
Â  Â  };
Â  Â Â 
Â  Â  const calculatePerpendicularFootApprox = (lineLat1, lineLon1, lineLat2, lineLon2, pointLat, pointLon) => {
Â  Â  Â  Â  const dx = lineLon2 - lineLon1;
Â  Â  Â  Â  const dy = lineLat2 - lineLat1;
Â  Â  Â  Â  const lineLenSq = dx * dx + dy * dy;
Â  Â  Â  Â  if (lineLenSq < 1e-9) return { latitude: lineLat1, longitude: lineLon1 };
Â  Â  Â  Â  const t = ((pointLon - lineLon1) * dx + (pointLat - lineLat1) * dy) / lineLenSq;
Â  Â  Â  Â  if (t < 0) return { latitude: lineLat1, longitude: lineLon1 };
Â  Â  Â  Â  if (t > 1) return { latitude: lineLat2, longitude: lineLon2 };
Â  Â  Â  Â  return { latitude: lineLat1 + t * dy, longitude: lineLon1 + t * dx };
Â  Â  };
Â  Â Â 
Â  Â  const getSideOfLine = (pointLat, pointLon, lineLat1, lineLon1, lineLat2, lineLon2) => {
Â  Â  Â  Â  return (lineLon2 - lineLon1) * (pointLat - lineLat1) - (lineLat2 - lineLat1) * (pointLon - lineLon1);
Â  Â  };

Â  Â  const getIntersectionTime = (p1, p2, l1, l2, l3, l4) => {
Â  Â  Â  Â  const A = (l4 - l2) * (p2.lon - p1.lon) - (l3 - l1) * (p2.lat - p1.lat);
Â  Â  Â  Â  if (A === 0) return null;
Â  Â  Â  Â  const B = (l3 - l1) * (p1.lat - l2) - (l4 - l2) * (p1.lon - l1);
Â  Â  Â  Â  const ratio = B / A;
Â  Â  Â  Â  if (ratio < 0 || ratio > 1) return null;
Â  Â  Â  Â  return p1.time + (p2.time - p1.time) * ratio;
Â  Â  };

Â  Â  if (!lastPosition) {
Â  Â  Â  Â  lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
Â  Â  Â  Â  previousSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const currentSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
Â  Â  const isCrossingLine = (previousSideOfLine > 0 && currentSideOfLine < 0) || (previousSideOfLine < 0 && currentSideOfLine > 0);
Â  Â  const timeSinceLastLap = currentTime - lastLapTime;
Â  Â  const isCoolDownOver = (lapCount === 0) || (timeSinceLastLap >= lapCoolDown);

Â  Â  const P = calculatePerpendicularFootApprox(LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon, currentLat, currentLon);
Â  Â  const distanceToStartLine = calculateDistance(currentLat, currentLon, P.latitude, P.longitude);
Â  Â  const isNearStartLine = distanceToStartLine <= gpsThresholdValue;

Â  Â  if (isCrossingLine && isCoolDownOver && isNearStartLine) {
Â  Â  Â  Â Â 
Â  Â  Â  Â  const timeDelta = currentTime - lastPosition.time;
Â  Â  Â  Â  const speed = position.coords.speed || 0;Â 
Â  Â  Â  Â  const distanceMoved = speed * timeDelta / 1000;Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  const deltaLat = currentLat - lastPosition.lat;
Â  Â  Â  Â  const deltaLon = currentLon - lastPosition.lon;
Â  Â  Â  Â  const currentToLastDistance = calculateDistance(currentLat, currentLon, lastPosition.lat, lastPosition.lon);

Â  Â  Â  Â  let predictedLat, predictedLon;
Â  Â  Â  Â  if (currentToLastDistance > 0) {
Â  Â  Â  Â  Â  Â  const ratio = distanceMoved / currentToLastDistance;
Â  Â  Â  Â  Â  Â  predictedLat = currentLat + deltaLat * ratio;
Â  Â  Â  Â  Â  Â  predictedLon = currentLon + deltaLon * ratio;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  predictedLat = currentLat;
Â  Â  Â  Â  Â  Â  predictedLon = currentLon;
Â  Â  Â  Â  }

Â  Â  Â  Â  const predictedPosition = {
Â  Â  Â  Â  Â  Â  lat: predictedLat,
Â  Â  Â  Â  Â  Â  lon: predictedLon,
Â  Â  Â  Â  Â  Â  time: currentTime + timeDelta
Â  Â  Â  Â  };

Â  Â  Â  Â  const estimatedCrossingTime = getIntersectionTime(lastPosition, predictedPosition, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
Â  Â  Â  Â Â 
Â  Â  Â  Â  let lapTimeBase;
Â  Â  Â  Â  if (estimatedCrossingTime && Math.abs(estimatedCrossingTime - currentTime) < 10000) {
Â  Â  Â  Â  Â  Â  lapTimeBase = estimatedCrossingTime;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  lapTimeBase = currentTime;
Â  Â  Â  Â  }

Â  Â  Â  Â  lapCount++;
Â  Â  Â  Â  const lapDuration = lapTimeBase - lapStartTime;
Â  Â  Â  Â  lapTimePrint(lapDuration);Â  Â Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  cancelAnimationFrame(lapTimerId);
Â  Â  Â  Â  if (elem.display1) elem.display1.textContent = lapTimeToString(lapDuration);

Â  Â  Â  Â  if (lapFixedDisplayTimeoutId) {
Â  Â  Â  Â  Â  Â  Â clearTimeout(lapFixedDisplayTimeoutId);
Â  Â  Â  Â  }
Â  Â  Â  Â  lapFixedDisplayTimeoutId = setTimeout(() => {
Â  Â  Â  Â  Â  Â  if (swState === SW_STATE.RUN) {
Â  Â  Â  Â  Â  Â  Â  Â  lapStartTime = lapTimeBase;
Â  Â  Â  Â  Â  Â  Â  Â  startRealtimeLap();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 10000);
Â  Â  Â  Â Â 
Â  Â  Â  Â  lastLapTime = lapTimeBase;
Â  Â  }

Â  Â  lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
Â  Â  previousSideOfLine = currentSideOfLine;
}

window.addEventListener('load', () => {
Â  Â  if ('serviceWorker' in navigator) {
Â  Â  Â  Â  navigator.serviceWorker.register('/service-worker.js')
Â  Â  Â  Â  Â  Â  .then(registration => {
Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  .catch(error => {
Â  Â  Â  Â  Â  Â  });
Â  Â  }

Â  Â  elem.display = document.getElementById('display');
Â  Â  elem.display1 = document.getElementById('display1');
Â  Â  elem.lap_list = document.getElementById('lap_list');
Â  Â  elem.statusDisplay = document.getElementById('status-display');
Â  Â  elem.debugInfo = document.getElementById('debugInfo');
Â  Â  elem.startButton = document.getElementById('start');
Â  Â  elem.resetButton = document.getElementById('reset');
Â  Â  elem.lapButton = document.getElementById('lap');
Â  Â  elem.gpsButton = document.getElementById('gpsButton');
Â  Â  elem.getSettingsBtn = document.getElementById('getSettingsBtn');
Â  Â  elem.nmeaLog = document.getElementById('nmeaLog');Â 

Â  Â  if (elem.startButton) elem.startButton.addEventListener('click', clickStartSW);
Â  Â  if (elem.lapButton) elem.lapButton.addEventListener('click', clickLapSW);
Â  Â  if (elem.resetButton) elem.resetButton.addEventListener('click', clickResetSW);
Â  Â  if (elem.gpsButton) elem.gpsButton.addEventListener('click', clickGpsButton);
Â  Â  if (elem.getSettingsBtn) elem.getSettingsBtn.addEventListener('click', getSettings);
Â  Â Â 
Â  Â  updateButtonDisplay();
Â  Â  totalTimePrint(0);
Â  Â  if (elem.display1) elem.display1.textContent = '00:00.000';
Â  Â  getSettings();
Â  Â  updateDebugDisplay();
});
</script>
</body>

</html>
