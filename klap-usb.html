<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>KLAP-ver3 (WebUSB 10HzÂØæÂøú)</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #000000;
            color: #ffffff;
            padding: 10px;
            position: relative;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #1c1c1e;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 100%;
            margin: 20px auto;
            width: 100%;
            box-sizing: border-box;
            height: 100%;
            position: relative;
        }
        
        #main-content {
            display: flex;
            width: 100%;
            gap: 20px;
            align-items: flex-start;
            justify-content: space-between;
            flex-grow: 1;
            margin-bottom: 20px;
        }

        #time-display-column {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
        }

        #lap-list-column {
            display: flex;
            flex-direction: column;
            width: 400px;
            flex-shrink: 0;
        }
        
        #display1 {
            font-size: 90px;
            font-weight: bold;
            color: #eeeeee;
            margin-bottom: 5px;
        }

        #display {
            font-size: 60px;
            font-weight: bold;
            color: #cccccc;
            margin-bottom: 10px;
        }

        #lap_list {
            width: 100%;
            height: 200px;
            overflow-y: auto;
            border: none;
            border-radius: 5px;
            background-color: #1c1c1e;
            padding: 10px;
        }

        #lap_list div {
            font-size: 2.5em;
            margin-bottom: 5px;
            color: #dddddd;
        }

        #buttons-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 15px;
            padding-top: 10px;
            flex-wrap: wrap; /* „Éú„Çø„É≥„ÅåÂ§ö„ÅÑ„ÅÆ„ÅßÊäò„ÇäËøî„Åó„ÇíË®±ÂèØ */
        }

        .button {
            border: 1px solid #3a3a3c;
            background-color: #2c2c2e;
            padding: 10px 15px;
            color: #ffffff;
            font-size: 16px;
            font-weight: 500;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            flex-grow: 1;
            min-width: 80px; /* „Éú„Çø„É≥„ÅÆÊúÄÂ∞èÂπÖ */
        }
        
        .button:hover { background-color: #4a4a4e; }
        #start:active { background-color: #4a804a; }
        #reset:active { background-color: #993333; }
        #lap:active { background-color: #4a4a4e; }
        
        .no-setting { background-color: #ff4d4d; }
        .no-setting:hover { background-color: #ff6666; }
        .no-setting:active { background-color: #e64444; }

        .no-gps { background-color: #ff4d4d; }
        .no-gps:hover { background-color: #ff6666; }
        .no-gps:active { background-color: #e64444; }
        
        .active-blue { background-color: #007aff; }
        .active-blue:hover { background-color: #3399ff; }
        .active-blue:active { background-color: #0066cc; }

        #debug-overlay {
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 14px;
            line-height: 1.5;
            width: 100%;
            box-sizing: border-box;
            pointer-events: none;
            opacity: 0.9;
            text-align: left;
        }
        .status-text {
            margin: 0;
        }
        #debug-overlay #debugInfo {
            margin-top: 5px;
            line-height: 1.2;
        }
        /* NMEA„É≠„Ç∞Ë°®Á§∫„Ç®„É™„Ç¢„ÅÆ„Çπ„Çø„Ç§„É´ */
        #nmeaLog {
            height: 30px; 
            overflow: hidden; 
            border: 1px solid #ccc; 
            padding: 5px; 
            font-size: 10px;
            background-color: #000;
            white-space: pre; 
            pointer-events: all; 
            line-height: 1;
        }
        
        @media (max-width: 480px) {
            #main-content {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            #time-display-column, #lap-list-column {
                width: 100%;
                align-items: center;
            }
            #buttons-row {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                align-items: center;
            }
            .button {
                width: auto;
                flex-grow: 1;
                padding: 10px 8px;
                font-size: 14px;
                min-width: 70px;
                margin: 5px 0;
            }
            #display1 { font-size: 40px; }
            #display { font-size: 25px; }
            #lap_list div {
                font-size: 1.6em;
            }
            #debug-overlay {
                width: auto;
            }
            #nmeaLog {
                font-size: 8px;
            }
        }
    </style>
</head>

<body>
<div id="container">
    <div id="debug-overlay">
        <p id="status-display" class="status-text">GPSË®≠ÂÆö: Êú™ÂèñÂæó</p>
        <div id="debugInfo" class="status-text"></div>
        <p class="status-text">NMEA Raw Data (Latest):</p>
        <pre id="nmeaLog">No NMEA data yet...</pre>
    </div>
    
    <div id="main-content">
        <div id="time-display-column">
            <div id='display1'>00:00.000</div>
            <div id='display'>00:00:00.000</div>
        </div>
        <div id="lap-list-column">
            <div id='lap_list'></div>
        </div>
    </div>
    <div id="buttons-row">
        <button id="start" class="button">start</button>
        <button id="lap" class="button">lap</button>
        <button id="reset" class="button">reset</button>
        <button id="gpsButton" class="button no-gps">GPS</button>
        <button id="getSettingsBtn" class="button no-setting">GET</button>
        <button id="set10HzButton" class="button no-setting" disabled>10HzË®≠ÂÆö</button>
    </div>
</div>

<script>
'use strict';
// --- „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ---
const SW_STATE = { STOP: 0, RUN: 1, PAUSE: 2 };
let swState = SW_STATE.STOP;
let startTime = 0;
let lapRecords = [];
let lapCount = 0;
let countUpTimerId = null;
let lapTimerId = null;
let lapStartTime = 0;
let isGpsRunning = false;
let lastPosition = null;
let previousSideOfLine = null;
let lastLapTime = 0;
let gpsThresholdValue = 20;
let lapCoolDown = 15000;
let isSettingsLoaded = false;
let lapFixedDisplayTimeoutId = null;

const elem = {
    display: null,
    display1: null,
    lap_list: null,
    statusDisplay: null,
    debugInfo: null,
    startButton: null,
    resetButton: null,
    lapButton: null,
    gpsButton: null,
    getSettingsBtn: null,
    nmeaLog: null,
    set10HzButton: null // üí° ËøΩÂä†
};

// GPS„É©„ÉÉ„ÉóË®àÊ∏¨Áî®Â§âÊï∞ - localStorage„Åã„ÇâË™≠„ÅøËæº„ÇÄ
let LAP_LINE_P1 = { lat: 0, lon: 0 };
let LAP_LINE_P2 = { lat: 0, lon: 0 };

// --- WebUSBÈñ¢ÈÄ£„ÅÆ„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ---
let device = null;
let keepReading = true;
let nmeaBuffer = '';
const NMEA_VENDOR_ID = 0x1546;    
const NMEA_PRODUCT_ID = 0x01A8;  
const IN_ENDPOINT = 2;           
const OUT_ENDPOINT = 2; // üí° OUT„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÇíËøΩÂä†
const INTERFACE_NUMBER = 1;

// --- Êõ¥Êñ∞„É¨„Éº„Éà/„Éá„Éê„ÉÉ„Ç∞Ë°®Á§∫Áî®Â§âÊï∞ ---
let lastUpdateTime = 0; 
let updateCounter = 0; 
let displayRateTimer = null; 
let currentUpdateRate = 0; 
let currentLat = 0.0;
let currentLon = 0.0;
let latestRmcStatus = 'N/A';
let latestRmcRawLatLon = 'N/A';

// --- „Çπ„Éà„ÉÉ„Éó„Ç¶„Ç©„ÉÉ„ÉÅÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞ÔºàÁúÅÁï•Ôºâ ---

const totalTimePrint = (time) => {
    let h = Math.floor(time / 3600000);
    let m = Math.floor((time % 3600000) / 60000);
    let s = Math.floor((time % 60000) / 1000);
    let ms = Math.floor(time % 1000);
    
    h = ('0' + h).slice(-2);
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    if (elem.display) elem.display.textContent = `${h}:${m}:${s}.${ms}`;
};

const lapTimeToString = (time) => {
    let m = Math.floor(time / 60000);
    let s = Math.floor(time % 60000 / 1000);
    let ms = Math.floor(time % 1000);
    
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    return `${m}:${s}.${ms}`;
};

const countUp = () => {
    countUpTimerId = requestAnimationFrame(() => {
        const now = Date.now();
        const elapsedTime = now - startTime;
        totalTimePrint(elapsedTime);
        countUp();
    });
};

const startRealtimeLap = () => {
    if (swState === SW_STATE.RUN) {
        lapTimerId = requestAnimationFrame(() => {
            const now = Date.now();
            const lapElapsedTime = now - lapStartTime;
            const lapDisplay = lapTimeToString(lapElapsedTime);
            if (elem.display1) elem.display1.textContent = lapDisplay;
            startRealtimeLap();
        });
    }
};

const lapTimePrint = (time) => {    
    const lapDuration = lapTimeToString(time);
    const lapDiv = document.createElement('div');
    lapDiv.textContent = `[${lapCount}] ${lapDuration}`;    
    lapDiv.style.fontSize = '2.5em';
    if (elem.lap_list) {
        elem.lap_list.insertBefore(lapDiv, elem.lap_list.firstChild);
    }
    lapRecords.push({ count: lapCount, time: lapDuration });    
};

const updateButtonDisplay = () => {
    if (elem.lapButton) {
        elem.lapButton.style.display = (swState === SW_STATE.RUN) ? 'inline-block' : 'none';
    }
    if (elem.resetButton) {
        elem.resetButton.style.display = (swState === SW_STATE.STOP || swState === SW_STATE.PAUSE) ? 'inline-block' : 'none';
    }
    if (elem.startButton) {
        elem.startButton.textContent = (swState === SW_STATE.RUN) ? 'stop' : 'start';
    }
};

const clickStartSW = () => {
    if (!isSettingsLoaded && swState === SW_STATE.STOP) {
        if (elem.debugInfo) {
            elem.debugInfo.innerHTML = `GPSË®≠ÂÆö„ÅåÊú™ÂèñÂæó„Åß„Åô„ÄÇÊâãÂãï„Åß„ÅÆË®àÊ∏¨„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ<br>${elem.debugInfo.innerHTML}`;
        }
    }
    
    if (swState === SW_STATE.STOP) {
        swState = SW_STATE.RUN;
        startTime = Date.now();
        lapStartTime = Date.now();
        lapCount = 0;
        elem.lap_list.innerHTML = '';
        countUp();
        startRealtimeLap();
    } else if (swState === SW_STATE.RUN) {
        swState = SW_STATE.PAUSE;
        cancelAnimationFrame(countUpTimerId);
        cancelAnimationFrame(lapTimerId);
        if (lapFixedDisplayTimeoutId) {
            clearTimeout(lapFixedDisplayTimeoutId);
        }
    } else if (swState === SW_STATE.PAUSE) {
        swState = SW_STATE.RUN;
        const now = Date.now();
        const pausedTime = now - lapStartTime;
        startTime += pausedTime;
        lapStartTime = now;
        countUp();
        startRealtimeLap();
    }
    updateButtonDisplay();
};

const clickLapSW = () => {
    if (swState === SW_STATE.RUN) {
        lapCount++;
        const now = Date.now();
        const lapDuration = now - lapStartTime;
        lapTimePrint(lapDuration);    
        lapStartTime = now;
        cancelAnimationFrame(lapTimerId);
        startRealtimeLap();
    }
};

const clickResetSW = () => {
    swState = SW_STATE.STOP;
    startTime = 0;
    lapRecords = [];
    lapCount = 0;
    cancelAnimationFrame(countUpTimerId);
    cancelAnimationFrame(lapTimerId);
    if (lapFixedDisplayTimeoutId) {
        clearTimeout(lapFixedDisplayTimeoutId);
    }
    totalTimePrint(0);
    if (elem.lap_list) elem.lap_list.innerHTML = '';
    if (elem.display1) elem.display1.textContent = '00:00.000';
    updateButtonDisplay();
    stopGps();
};

const clickGpsButton = () => {
    if (!isGpsRunning) {
        startGps();
    } else {
        stopGps();
    }
};

const getSettings = () => {
    const p1Lat = localStorage.getItem('startLineP1Lat');
    const p1Lon = localStorage.getItem('startLineP1Lon');
    const p2Lat = localStorage.getItem('startLineP2Lat');
    const p2Lon = localStorage.getItem('startLineP2Lon');
    const threshold = localStorage.getItem('gpsThreshold');
    const coolDown = localStorage.getItem('lapCoolDownTime');    

    if (p1Lat && p1Lon && p2Lat && p2Lon) {
        LAP_LINE_P1 = { lat: parseFloat(p1Lat), lon: parseFloat(p1Lon) };
        LAP_LINE_P2 = { lat: parseFloat(p2Lat), lon: parseFloat(p2Lon) };
        gpsThresholdValue = threshold ? parseFloat(threshold) : 20;
        lapCoolDown = coolDown ? parseFloat(coolDown) : 15000;    

        elem.statusDisplay.textContent = `GPSË®≠ÂÆö: OK (ÈñæÂÄ§: ${gpsThresholdValue}m / C/D: ${lapCoolDown / 1000}Áßí)`;
        elem.debugInfo.innerHTML = "GPSË®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü„ÄÇ";
        isSettingsLoaded = true;
        elem.getSettingsBtn.classList.remove('no-setting');
        elem.getSettingsBtn.classList.add('active-blue');
    } else {
        elem.statusDisplay.textContent = 'GPSË®≠ÂÆö: Êú™Ë®≠ÂÆöÔºàË®≠ÂÆö„ÉÑ„Éº„É´„Åß‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ';
        elem.debugInfo.innerHTML = "localStorage„Å´GPSË®≠ÂÆö„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ";
        isSettingsLoaded = false;
        elem.getSettingsBtn.classList.remove('active-blue');
        elem.getSettingsBtn.classList.add('no-setting');
    }
};


// ----------------------------------------------------------------------
// WebUSB/NMEA/Êõ¥Êñ∞„É¨„Éº„ÉàÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞ 
// ----------------------------------------------------------------------

// NMEA„ÅÆDMM„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºàÂ∫¶ÂàÜ.ÂàÜÔºâ„Çí10ÈÄ≤Êï∞„Å´Â§âÊèõ„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
function dmsToDecimal(dmm, direction) {
    if (!dmm) return NaN;
    
    const dotIndex = dmm.indexOf('.');
    
    if (dotIndex !== -1) {
        // üí° NMEA DMMÂΩ¢Âºè„Åß„ÅØ„ÄÅ„ÄåÂàÜ„Äç„ÅØÂ∏∏„Å´Â∞èÊï∞ÁÇπÂâç„ÅÆ2Ê°Å„Å®Âõ∫ÂÆö
        const minuteStartIndex = dotIndex - 2;
        
        if (minuteStartIndex > 0) {
            const degrees = parseInt(dmm.substring(0, minuteStartIndex));
            const minutes = parseFloat(dmm.substring(minuteStartIndex));
            
            if (isNaN(degrees) || isNaN(minutes)) return NaN;
            
            let decimal = degrees + (minutes / 60);

            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        } else {
            // Â∫¶Êï∞„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Å™„Å©„ÅÆÁï∞Â∏∏„Éá„Éº„Çø
            return NaN;
        }

    } else {
        // Â∞èÊï∞ÁÇπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É≠„Ç∏„ÉÉ„ÇØ
        const num = parseFloat(dmm);
        if (isNaN(num)) return NaN;
        
        if (dmm.length >= 4) {
            const minuteRaw = dmm.slice(-2);
            const degreeRaw = dmm.slice(0, -2);
            
            const degrees = parseInt(degreeRaw);
            const minutes = parseInt(minuteRaw);
            
            if (isNaN(degrees) || isNaN(minutes)) return NaN;
            
            let decimal = degrees + (minutes / 60);

            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        } else {
            return NaN;
        }
    }
}

// NMEA„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËß£Êûê„Åó„ÄÅ‰ΩçÁΩÆÊÉÖÂ†±„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøî„Åô (Á∞°Áï•Âåñ„Åï„Çå„Åü„Éë„Éº„Çµ„Éº)
function parseNmeaLine(line) {
    const parts = line.split(',');
    
    if ((parts[0].endsWith('RMC') || parts[0].endsWith('RMC')) && parts.length >= 10 && parts[2] === 'A') {
        const lat = dmsToDecimal(parts[3], parts[4]);
        const lon = dmsToDecimal(parts[5], parts[6]); 
        
        const speedKnot = parseFloat(parts[7]) || 0;
        const speedMps = speedKnot * 0.514444; 

        if (isNaN(lat) || isNaN(lon)) return null;

        return {
            coords: {
                latitude: lat,
                longitude: lon,
                speed: speedMps, 
                accuracy: 1
            },
            timestamp: Date.now() 
        };
    }
    return null;
}

// NMEA„Éá„Éº„ÇøÂá¶ÁêÜ„Éê„ÉÉ„Éï„Ç°„ÇíÁÆ°ÁêÜ„Åó„ÄÅË°å„Åî„Å®„Å´„Éë„Éº„Çµ„Éº„Å´Ê∏°„Åô
function processNmeaData(data) {
    nmeaBuffer += data;
    let newlineIndex;

    while ((newlineIndex = nmeaBuffer.indexOf('\n')) !== -1) {
        const line = nmeaBuffer.substring(0, newlineIndex).trim();
        nmeaBuffer = nmeaBuffer.substring(newlineIndex + 1);

        if (line.startsWith('$') && line.length > 5) {
            const position = parseNmeaLine(line);
            
            if (line.includes('RMC')) {
                 try {
                     const parts = line.split(',');
                     
                     // 1. Â∞èÊï∞ÁÇπ‰ª•‰∏ã6Ê°Å„ÅÆ„Éá„Ç∑„Éû„É´Á∑ØÂ∫¶„ÉªÁµåÂ∫¶„ÇíÊõ¥Êñ∞ (ÁîªÈù¢‰∏äÈÉ®Ë°®Á§∫Áî®)
                     currentLat = dmsToDecimal(parts[3], parts[4]);
                     currentLon = dmsToDecimal(parts[5], parts[6]);

                     // 2. RMC„Çπ„ÉÜ„Éº„Çø„Çπ„Å®„ÄÅÁîü„ÅÆÁ∑ØÂ∫¶ÁµåÂ∫¶„Éá„Éº„ÇøÔºàÁîªÈù¢„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ„ÇíÊõ¥Êñ∞
                     latestRmcStatus = parts.length > 2 ? parts[2] : 'N/A';
                     const rawLat = parts.length > 3 ? `${parts[3]} ${parts[4]}` : 'N/A';
                     const rawLon = parts.length > 5 ? `${parts[5]} ${parts[6]}` : 'N/A';
                     latestRmcRawLatLon = `${rawLat} / ${rawLon}`;
                     
                 } catch (e) {
                     // NMEAËß£Êûê„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                 }
             }
            
            if (position && swState === SW_STATE.RUN) {
                onWebUsbPositionUpdate(position); 
            }
        }
    }
}

// 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞„É¨„Éº„Éà„ÇíË®àÁÆó„Åó„Å¶Ë°®Á§∫„Åô„Çã„Çø„Ç§„Éû„Éº„ÇíÈñãÂßã
function startRateMeasurement() {
    if (displayRateTimer !== null) {
        clearInterval(displayRateTimer);
        displayRateTimer = null;
    }
    
    currentUpdateRate = 0;
    updateCounter = 0;
    
    displayRateTimer = setInterval(() => {
        currentUpdateRate = updateCounter; 
        updateCounter = 0; 
        updateDebugDisplay(); 
    }, 1000); 
}

// Êõ¥Êñ∞„É¨„Éº„Éà„ÅÆË®àÊ∏¨„ÇíÂÅúÊ≠¢
function stopRateMeasurement() {
    if (displayRateTimer !== null) {
        clearInterval(displayRateTimer);
        displayRateTimer = null; 
    }
    currentUpdateRate = 0;
}

// „Éá„Éê„ÉÉ„Ç∞Ë°®Á§∫„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
function updateDebugDisplay() {
    if (!elem.debugInfo) return;

    const rateText = `„É¨„Éº„Éà: ${currentUpdateRate.toFixed(0)} Hz`;
    const latLonText = `DEC: ${currentLat.toFixed(6)} / ${currentLon.toFixed(6)}`;
    const rmcStatusText = `RMC Status: ${latestRmcStatus}`;
    const rmcRawText = `RAW DMM: ${latestRmcRawLatLon}`;
    const speedText = `ÈÄüÂ∫¶: ${(lastPosition && lastPosition.speed !== null) ? lastPosition.speed.toFixed(2) : 'N/A'} m/s`;
    const lapCountText = `Âë®ÂõûÊï∞: ${lapCount}`; 

    elem.debugInfo.innerHTML = `
        ${rateText} | ${rmcStatusText}<br>
        ${latLonText}<br>
        ${rmcRawText}<br>
        ${speedText} | ${lapCountText}
    `;
    
    const statusColor = (latestRmcStatus === 'A') ? 'lime' : (latestRmcStatus === 'V' ? 'red' : 'white');
    elem.debugInfo.style.color = statusColor;
}

// WebUSB„Éá„Éº„ÇøË™≠„ÅøÂèñ„Çä„É´„Éº„Éó
async function readLoop() {
    const nmeaLogElement = elem.nmeaLog; 
    
    while (device && keepReading) {
        try {
            const result = await device.transferIn(IN_ENDPOINT, 512); 
            if (result.status === 'ok' && result.data) {
                const decoder = new TextDecoder('iso-8859-1');
                const nmeaData = decoder.decode(result.data);
                
                updateCounter++;

                if (nmeaLogElement && nmeaData.length > 0) {
                    const lines = nmeaData.trim().split('\n');
                    if (lines.length > 0) {
                        const latestLine = lines[lines.length - 1].trim(); 
                        nmeaLogElement.textContent = latestLine; 
                    }
                }
                
                processNmeaData(nmeaData); 
            }
        } catch (error) {
            if (keepReading) {
                elem.debugInfo.innerHTML = `USBË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº: ${error.message}`;
            }
            break; 
        }
    }
}

// ----------------------------------------------------------------------
// üí° UBXË®≠ÂÆö„Ç≥„Éû„É≥„Éâ„ÅÆÂÆöÁæ©„Å®ÈÄÅ‰ø°
// ----------------------------------------------------------------------

// GNRMC„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂá∫Âäõ„É¨„Éº„Éà„Çí10Hz (100msÂë®Êúü) „Å´Ë®≠ÂÆö„Åô„ÇãUBX„Ç≥„Éû„É≥„Éâ (CFG-MSG)
// 0xF0: NMEA, 0x04: RMC, Rate=0x01 (1Hz/Rate * 10 = 10Hz)
const UBX_10HZ_RMC_CMD = new Uint8Array([
    0xB5, 0x62, // Sync Bytes
    0x06, 0x01, // Class (CFG) / ID (CFG-MSG)
    0x08, 0x00, // Length (8 bytes)
    0xF0, 0x04, // Message Class (NMEA F0) / ID (RMC 04)
    0x01, 0x00, // Port 1 (UART1) Rate: 10Hz (0x01) / Port 2 (USB) Rate: 0
    0x00, 0x00, // Port 3 / Port 4 Rate: 0
    0x00, 0x00, // Port 5 / Port 6 Rate: 0
    0xFA, 0x0A  // Checksum A / Checksum B
]);

async function sendUblox10HzConfig() {
    if (!device) {
        elem.debugInfo.innerHTML = 'USB„Éá„Éê„Ç§„Çπ„ÅåÊé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ';
        return;
    }
    
    try {
        elem.set10HzButton.textContent = 'Ë®≠ÂÆöÈÄÅ‰ø°‰∏≠...';
        
        // UBX„Ç≥„Éû„É≥„Éâ„ÇíGPS„É¢„Ç∏„É•„Éº„É´„Å´ÈÄÅ‰ø°
        const result = await device.transferOut(OUT_ENDPOINT, UBX_10HZ_RMC_CMD);
        
        if (result.status === 'ok') {
            elem.debugInfo.innerHTML = 'GPS„É¢„Ç∏„É•„Éº„É´„Å´10HzË®≠ÂÆö„Ç≥„Éû„É≥„Éâ„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü„ÄÇ**10Áßí„Åª„Å©ÂæÖ„Å£„Å¶**Êõ¥Êñ∞„É¨„Éº„Éà„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ';
            elem.set10HzButton.textContent = '10HzË®≠ÂÆö (OK)';
            setTimeout(() => {
                if (elem.set10HzButton) elem.set10HzButton.textContent = '10HzË®≠ÂÆö';
            }, 5000); 
        } else {
            elem.debugInfo.innerHTML = `Ë®≠ÂÆöÈÄÅ‰ø°„Ç®„É©„Éº: ${result.status}`;
            elem.set10HzButton.textContent = '10HzË®≠ÂÆö (Â§±Êïó)';
        }
    } catch (error) {
        elem.debugInfo.innerHTML = `USBÈÄÅ‰ø°„Ç®„É©„Éº: ${error.message}`;
        elem.set10HzButton.textContent = '10HzË®≠ÂÆö („Ç®„É©„Éº)';
    }
}

// WebUSBÊé•Á∂ö„ÇíÈñãÂßã
async function startWebUsbGps() {
    try {
        elem.statusDisplay.textContent = 'USB„Éá„Éê„Ç§„Çπ„ÇíÊ§úÁ¥¢‰∏≠...';
        elem.gpsButton.textContent = 'Êé•Á∂ö‰∏≠...'; 

        device = await navigator.usb.requestDevice({
            filters: [{ vendorId: NMEA_VENDOR_ID, productId: NMEA_PRODUCT_ID }]
        });
        
        await device.open();
        
        if (device.configuration === null) {
            await device.selectConfiguration(device.configurations[0].configurationValue);
        }
        
        await device.claimInterface(INTERFACE_NUMBER);
        
        elem.statusDisplay.textContent = 'GPS„É¢„Ç∏„É•„Éº„É´Êé•Á∂öÂÆå‰∫Ü„ÄÇ„Éá„Éº„ÇøÁõ£Ë¶ñ‰∏≠...';
        elem.gpsButton.textContent = 'GPS (ÂÅúÊ≠¢)';
        elem.gpsButton.classList.remove('no-gps');
        elem.gpsButton.classList.add('active-blue');
        
        // üí° Êé•Á∂öÊàêÂäüÊôÇ„Å´10HzË®≠ÂÆö„Éú„Çø„É≥„ÇíÊúâÂäπÂåñ
        if (elem.set10HzButton) {
            elem.set10HzButton.disabled = false;
            elem.set10HzButton.classList.remove('no-setting');
            elem.set10HzButton.classList.add('active-blue');
        }
        
        isGpsRunning = true;
        keepReading = true;
        
        startRateMeasurement(); 
        readLoop(); 
        
    } catch (error) {
        elem.debugInfo.innerHTML = `USBÊé•Á∂ö„Ç®„É©„Éº: ${error.message}`;
        stopGps();
    }
}

// GPSÁõ£Ë¶ñ„ÇíÂÅúÊ≠¢„Åô„Çã
async function stopGps() {
    stopRateMeasurement(); 

    keepReading = false;
    if (device) {
        try {
            await device.releaseInterface(INTERFACE_NUMBER);
            await device.close();
        } catch (error) {
            // „Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
        }
        device = null;
    }
    isGpsRunning = false;
    elem.statusDisplay.textContent = 'GPSÁõ£Ë¶ñÂÅúÊ≠¢';
    elem.gpsButton.textContent = 'GPS';
    elem.gpsButton.classList.remove('active-blue');
    elem.gpsButton.classList.add('no-gps');
    
    // üí° ÂÅúÊ≠¢ÊôÇ„Å´10HzË®≠ÂÆö„Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñ
    if (elem.set10HzButton) {
        elem.set10HzButton.disabled = true;
        elem.set10HzButton.classList.remove('active-blue');
        elem.set10HzButton.classList.add('no-setting');
        elem.set10HzButton.textContent = '10HzË®≠ÂÆö';
    }
    
    if(elem.nmeaLog) elem.nmeaLog.textContent = 'No NMEA data yet...';
    currentLat = 0.0;
    currentLon = 0.0;
    latestRmcStatus = 'N/A';
    latestRmcRawLatLon = 'N/A';
    lastPosition = null;
    updateDebugDisplay();
}

// WebUSB„Åã„Çâ„ÅÆ‰ΩçÁΩÆÊÉÖÂ†±Êõ¥Êñ∞Âá¶ÁêÜÔºàÁúÅÁï•Ôºâ
function onWebUsbPositionUpdate(position) {
    if (swState !== SW_STATE.RUN || !isGpsRunning) {
        return;
    }
    
    lastUpdateTime = Date.now();
    
    const currentLat = position.coords.latitude;
    const currentLon = position.coords.longitude;
    const currentTime = Date.now();
    
    // „Éò„É´„Éë„ÉºÈñ¢Êï∞Áæ§ÔºàÁúÅÁï•Ôºâ
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371e3;
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    };
    
    const calculatePerpendicularFootApprox = (lineLat1, lineLon1, lineLat2, lineLon2, pointLat, pointLon) => {
        const dx = lineLon2 - lineLon1;
        const dy = lineLat2 - lineLat1;
        const lineLenSq = dx * dx + dy * dy;
        if (lineLenSq < 1e-9) return { latitude: lineLat1, longitude: lineLon1 };
        const t = ((pointLon - lineLon1) * dx + (pointLat - lineLat1) * dy) / lineLenSq;
        if (t < 0) return { latitude: lineLat1, longitude: lineLon1 };
        if (t > 1) return { latitude: lineLat2, longitude: lineLon2 };
        return { latitude: lineLat1 + t * dy, longitude: lineLon1 + t * dx };
    };
    
    const getSideOfLine = (pointLat, pointLon, lineLat1, lineLon1, lineLat2, lineLon2) => {
        return (lineLon2 - lineLon1) * (pointLat - lineLat1) - (lineLat2 - lineLat1) * (pointLon - lineLon1);
    };

    const getIntersectionTime = (p1, p2, l1, l2, l3, l4) => {
        const A = (l4 - l2) * (p2.lon - p1.lon) - (l3 - l1) * (p2.lat - p1.lat);
        if (A === 0) return null;
        const B = (l3 - l1) * (p1.lat - l2) - (l4 - l2) * (p1.lon - l1);
        const ratio = B / A;
        if (ratio < 0 || ratio > 1) return null;
        return p1.time + (p2.time - p1.time) * ratio;
    };

    if (!lastPosition) {
        lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
        previousSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
        return;
    }

    const currentSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
    const isCrossingLine = (previousSideOfLine > 0 && currentSideOfLine < 0) || (previousSideOfLine < 0 && currentSideOfLine > 0);
    const timeSinceLastLap = currentTime - lastLapTime;
    const isCoolDownOver = (lapCount === 0) || (timeSinceLastLap >= lapCoolDown);

    const P = calculatePerpendicularFootApprox(LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon, currentLat, currentLon);
    const distanceToStartLine = calculateDistance(currentLat, currentLon, P.latitude, P.longitude);
    const isNearStartLine = distanceToStartLine <= gpsThresholdValue;

    if (isCrossingLine && isCoolDownOver && isNearStartLine) {
        
        const timeDelta = currentTime - lastPosition.time;
        const speed = position.coords.speed || 0; 
        const distanceMoved = speed * timeDelta / 1000; 
        
        const deltaLat = currentLat - lastPosition.lat;
        const deltaLon = currentLon - lastPosition.lon;
        const currentToLastDistance = calculateDistance(currentLat, currentLon, lastPosition.lat, lastPosition.lon);

        let predictedLat, predictedLon;
        if (currentToLastDistance > 0) {
            const ratio = distanceMoved / currentToLastDistance;
            predictedLat = currentLat + deltaLat * ratio;
            predictedLon = currentLon + deltaLon * ratio;
        } else {
            predictedLat = currentLat;
            predictedLon = currentLon;
        }

        const predictedPosition = {
            lat: predictedLat,
            lon: predictedLon,
            time: currentTime + timeDelta
        };

        const estimatedCrossingTime = getIntersectionTime(lastPosition, predictedPosition, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
        
        let lapTimeBase;
        if (estimatedCrossingTime && Math.abs(estimatedCrossingTime - currentTime) < 10000) {
            lapTimeBase = estimatedCrossingTime;
        } else {
            lapTimeBase = currentTime;
        }

        lapCount++;
        const lapDuration = lapTimeBase - lapStartTime;
        lapTimePrint(lapDuration);    
        
        cancelAnimationFrame(lapTimerId);
        if (elem.display1) elem.display1.textContent = lapTimeToString(lapDuration);

        if (lapFixedDisplayTimeoutId) {
             clearTimeout(lapFixedDisplayTimeoutId);
        }
        lapFixedDisplayTimeoutId = setTimeout(() => {
            if (swState === SW_STATE.RUN) {
                lapStartTime = lapTimeBase;
                startRealtimeLap();
            }
        }, 10000);
        
        lastLapTime = lapTimeBase;
    }

    lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
    previousSideOfLine = currentSideOfLine;
}

window.addEventListener('load', () => {
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
            })
            .catch(error => {
            });
    }

    elem.display = document.getElementById('display');
    elem.display1 = document.getElementById('display1');
    elem.lap_list = document.getElementById('lap_list');
    elem.statusDisplay = document.getElementById('status-display');
    elem.debugInfo = document.getElementById('debugInfo');
    elem.startButton = document.getElementById('start');
    elem.resetButton = document.getElementById('reset');
    elem.lapButton = document.getElementById('lap');
    elem.gpsButton = document.getElementById('gpsButton');
    elem.getSettingsBtn = document.getElementById('getSettingsBtn');
    elem.nmeaLog = document.getElementById('nmeaLog'); 
    elem.set10HzButton = document.getElementById('set10HzButton'); // üí° „Ç®„É¨„É°„É≥„ÉàÂèñÂæó

    if (elem.startButton) elem.startButton.addEventListener('click', clickStartSW);
    if (elem.lapButton) elem.lapButton.addEventListener('click', clickLapSW);
    if (elem.resetButton) elem.resetButton.addEventListener('click', clickResetSW);
    if (elem.gpsButton) elem.gpsButton.addEventListener('click', clickGpsButton);
    if (elem.getSettingsBtn) elem.getSettingsBtn.addEventListener('click', getSettings);
    // if (elem.set10HzButton) elem.set10HzButton.addEventListener('click', sendUblox10HzConfig);// üí° „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
    
    updateButtonDisplay();
    totalTimePrint(0);
    if (elem.display1) elem.display1.textContent = '00:00.000';
    getSettings();
    updateDebugDisplay();
});
</script>
</body>

</html>


